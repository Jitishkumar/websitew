import React, { useState, useRef, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  TouchableWithoutFeedback,
  Image,
  Dimensions,
  ActivityIndicator,
  Modal,
  PanResponder,
  ScrollView,
  Linking,
  TextInput,
  Animated,
  Share
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { Audio } from 'expo-av'; // Keep Audio from expo-av
import { useVideoPlayer, VideoView } from 'expo-video'; // Import from expo-video
import { useEvent } from 'expo'; // Import useEvent for video events
import { LinearGradient } from 'expo-linear-gradient';
import { useNavigation } from '@react-navigation/native';
import { useVideo } from '../context/VideoContext';
import { PostsService } from '../services/PostsService';
import { supabase } from '../config/supabase';
import { Alert } from 'react-native';
import CommentScreen from '../screens/CommentScreen';

const { width } = Dimensions.get('window');

const PostItem = ({ post, onOptionsPress }) => {
  // Early return if post is null or undefined
  if (!post) {
    console.warn('PostItem received null or undefined post');
    return null;
  }
  const [isLiked, setIsLiked] = useState(post.is_liked || false);
  const [likesCount, setLikesCount] = useState(post.likes?.[0]?.count || 0);
  const [commentsCount, setCommentsCount] = useState(post.comments?.[0]?.count || 0);
  const navigation = useNavigation();
  const touchTimer = useRef(null);
  const isTouchHolding = useRef(false);
  
  // Initialize Audio system for better video playback
  useEffect(() => {
    const setupAudio = async () => {
      try {
        await Audio.setAudioModeAsync({
          playsInSilentModeIOS: true,
          staysActiveInBackground: false,
          shouldDuckAndroid: true,
          playThroughEarpieceAndroid: false,
          allowsRecordingIOS: false,
        });
      } catch (error) {
        console.error('Failed to configure audio mode:', error);
      }
    };
    
    setupAudio();
  }, []);

  // Add this function to safely get the avatar URL
  const getAvatarUrl = () => {
    if (!post?.profiles?.avatar_url) return 'https://via.placeholder.com/150';
    
    let avatarPath = post.profiles.avatar_url;
    if (avatarPath.includes('media/media/') || avatarPath.includes('storage/v1/object/public/media/')) {
      const match = avatarPath.match(/([a-f0-9-]+\/avatar_[0-9]+\.jpg)/);
      if (match && match[1]) {
        avatarPath = match[1];
      } else {
        avatarPath = avatarPath.split('media/').pop();
      }
    }
    return `https://lckhaysswueoyinhfzyz.supabase.co/storage/v1/object/public/media/${avatarPath}`;
  };
  const [loading, setLoading] = useState(true);
  const [playing, setPlaying] = useState(false);
  const [videoError, setVideoError] = useState(false);
  const [imageLoaded, setImageLoaded] = useState(false);
  const [fullscreen, setFullscreen] = useState(false);
  const [lastTap, setLastTap] = useState(null);
  // Removed seekbar and controls related state variables
  const [showPauseIcon, setShowPauseIcon] = useState(false);
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const controlsTimeout = useRef(null);
  const pauseIconTimeout = useRef(null);
  
  // Create a video player instance using useVideoPlayer hook
  const videoPlayer = post?.type === 'video' && post?.media_url ? 
    useVideoPlayer(post.media_url, player => {
      if (player) {
        try {
          // Configure player on initialization
          player.volume = 1.0;
          player.loop = true; // Enable looping
        } catch (error) {
          console.warn(`Error configuring video player for post ${post?.id}:`, error);
        }
      }
    }) : null;
  
  // Use useEvent to track player state changes with safe fallbacks
  const { isPlaying } = videoPlayer ? useEvent(videoPlayer, 'playingChange', { 
    isPlaying: false // Default to false, will be updated when player is ready
  }) || { isPlaying: false } : { isPlaying: false };
  
  // Use useEvent to track loading state with safe fallbacks
  const { isLoaded, isBuffering } = videoPlayer ? useEvent(videoPlayer, 'loadingChange', {
    isLoaded: false,
    isBuffering: false
  }) || { isLoaded: false, isBuffering: false } : { isLoaded: false, isBuffering: false };
  
  // Use useEvent to track playback position with safe fallbacks
  const { position } = videoPlayer ? useEvent(videoPlayer, 'positionChange', {
    position: 0
  }) || { position: 0 } : { position: 0 };
  
  // Use useEvent to track errors with safe fallbacks
  const { hasError, errorMessage } = videoPlayer ? useEvent(videoPlayer, 'errorChange', {
    hasError: false,
    errorMessage: ''
  }) || { hasError: false, errorMessage: '' } : { hasError: false, errorMessage: '' };
  
  // Get video context
  const { 
    activeVideoId, 
    setActiveVideo, 
    clearActiveVideo, 
    isFullscreenMode, 
    setFullscreen: setContextFullscreen,
    trackVideoError,
    hasVideoError,
    addVisibleVideo,
    removeVisibleVideo,
    isVideoVisible
  } = useVideo();

  const handleProfilePress = () => {
    navigation.navigate('UserProfileScreen', { userId: post?.user_id || post?.user?.id });
  };

  const handleVideoPress = async () => {
    const now = Date.now();
    if (lastTap && (now - lastTap) < 300) {
      // Double tap - go to shorts screen for vertical scrolling
      // Pause the feed video first to prevent double audio
      if (videoPlayer) {
        try {
          console.log(`Pausing video for post ${post.id} on double tap (navigating to Shorts)`);
          videoPlayer.pause();
        } catch (error) {
          console.warn(`Error pausing video for post ${post.id} on double tap:`, error);
          // Don't block navigation due to pause error
        }
      }
      setPlaying(false);
      clearActiveVideo();
      
      // Get all video posts from the HomeScreen navigation params
      const homeRoute = navigation.getState().routes.find(route => route.name === 'Home');
      const videoPosts = homeRoute?.params?.videoPosts || [post]; // If no video posts available, just use current post
      
      // Find the index of the current post
      const currentIndex = videoPosts.findIndex(p => p.id === post.id);
      
      // Navigate to ShortsScreen with all video posts and current index
      navigation.navigate('Shorts', {
        posts: videoPosts,
        initialIndex: currentIndex >= 0 ? currentIndex : 0
      });
    } else {
      // Single tap - toggle play/pause
      const newPlayingState = !playing;
      setPlaying(newPlayingState);
      
      if (videoPlayer) {
        try {
          if (newPlayingState) {
            console.log(`Playing video for post ${post.id} on tap`);
            videoPlayer.play();
            setActiveVideo(post.id);
          } else {
            console.log(`Pausing video for post ${post.id} on tap`);
            videoPlayer.pause();
            clearActiveVideo();
          }
        } catch (error) {
          console.error(`Error toggling video playback for post ${post.id}:`, error);
        }
      }
    }
    setLastTap(now);
  };
  
  // Add touch handlers for press-to-pause functionality
  const handleTouchStart = () => {
    if (post.type === 'video') {
      // Clear any existing touch timer
      if (touchTimer.current) {
        clearTimeout(touchTimer.current);
      }
      
      // Set a timer to detect long press (300ms)
      touchTimer.current = setTimeout(() => {
        if (playing) {
          isTouchHolding.current = true;
          setPlaying(false);
          if (videoPlayer) {
            try {
              console.log(`Pausing video for post ${post.id} on long press`);
              videoPlayer.pause();
            } catch (error) {
              console.warn(`Error pausing video for post ${post.id} on long press:`, error);
            }
          }
        }
      }, 300);
    }
  };

  const handleTouchEnd = () => {
    // Clear the touch timer
    if (touchTimer.current) {
      clearTimeout(touchTimer.current);
      touchTimer.current = null;
    }
    
    // If we were holding and paused the video, resume playback
    if (isTouchHolding.current) {
      isTouchHolding.current = false;
      setPlaying(true);
      if (videoPlayer) {
        try {
          console.log(`Resuming video for post ${post.id} after long press`);
          videoPlayer.play();
          setActiveVideo(post.id);
        } catch (error) {
          console.error(`Error playing video for post ${post.id} after long press:`, error);
          setVideoError(true);
          trackVideoError(post.id, {
            hasError: true,
            timestamp: Date.now(),
            errorMessage: `Play error after long press: ${error?.message || 'Unknown error'}`,
            url: post.media_url
          });
        }
      }
    }
  };

  const handleFullscreenClose = () => {
    // First stop playback in fullscreen
    setPlaying(false);
    
    // Try to pause the video
    if (videoPlayer) {
      try {
        console.log(`Pausing video for post ${post.id} when closing fullscreen`);
        videoPlayer.pause();
      } catch (error) {
        console.warn(`Error pausing video for post ${post.id} when closing fullscreen:`, error);
      }
    }
    
    // Wait a moment to ensure video playback is stopped before closing modal
    setTimeout(() => {
      setFullscreen(false);
      setContextFullscreen(false);
      clearActiveVideo();
    }, 100);
  };

  // Update playback status based on videoPlayer events
  useEffect(() => {
    try {
      if (isLoaded && !isBuffering && position > 0) {
        // If we're getting valid playback updates, clear any previous error state
        if (videoError) {
          setVideoError(false);
        }
        
        // If this video had errors before but is now playing successfully, clear the error in context
        if (hasVideoError(post.id)) {
          trackVideoError(post.id, false);
        }
      }
    } catch (error) {
      console.error(`Error updating playback status for post ${post.id}:`, error);
      // Don't set error state here to prevent potential infinite loops
    }
  }, [isLoaded, isBuffering, position, post.id]);
  
  // Handle video errors
  useEffect(() => {
    if (hasError && errorMessage) {
      console.error(`Playback error detected for post ${post.id}:`, errorMessage);
      setVideoError(true);
      trackVideoError(post.id, {
        hasError: true,
        timestamp: Date.now(),
        errorMessage: `Playback error: ${errorMessage}`,
        url: post.media_url
      });
    }
  }, [hasError, errorMessage, post.id]);
  
  // formatTime function removed - no longer needed as we've removed video controls
  
  // PanResponder for seekbar removed - no longer needed as we've removed video controls
  
  // handleSeek function removed - no longer needed as we've removed video controls
  
  // Removed video controls completely as per user request
  const showVideoControls = () => {
    // No-op function - controls are completely removed
    return;
  };
  
  // Effect to handle when another video becomes active and to auto-play videos when they become visible
  useEffect(() => {
    if (activeVideoId && activeVideoId !== post?.id && playing) {
      // If another video is now active and this one is playing, pause this one
      setPlaying(false);
      
      // Use the ref to ensure we have the latest instance
      const player = videoPlayerRef.current;
      if (player) {
        try {
          console.log(`Pausing video for post ${post?.id} because another video became active`);
          // Check if the player is still valid before calling methods
          if (typeof player !== 'number' && player.pause) {
            player.pause();
          }
        } catch (error) {
          console.warn(`Error pausing video for post ${post?.id} when another became active:`, error);
          // This is not a critical error, so we don't need to set videoError or track it
        }
      }
    } else if (activeVideoId === post?.id && !playing && post.type === 'video') {
      // Auto-play when this video becomes the active video
      setPlaying(true);
      if (videoPlayer) {
        try {
          console.log(`Auto-playing video for post ${post.id} as it became visible`);
          videoPlayer.play();
        } catch (error) {
          console.warn(`Error auto-playing video for post ${post.id}:`, error);
        }
      }
    }
  }, [activeVideoId, post?.id, playing, post.type, videoPlayer]); // Added videoPlayer back to dependencies for auto-play

  // Cleanup effect with reference tracking
  const videoPlayerRef = useRef(videoPlayer);
  
  // Update ref when videoPlayer changes
  useEffect(() => {
    videoPlayerRef.current = videoPlayer;
  }, [videoPlayer]);
  
  // Cleanup effect
  useEffect(() => {
    return () => {
      // Use the ref to ensure we have the latest instance
      const player = videoPlayerRef.current;
      if (player) {
        try {
          console.log(`Cleaning up video player for post ${post?.id}`);
          // Check if the player is still valid before calling methods
          if (typeof player !== 'number' && player.pause) {
            player.pause();
          }
        } catch (error) {
          console.warn(`Error cleaning up video player for post ${post?.id}:`, error);
        }
      }
    };
  }, [post?.id]); // Only depend on post.id, not videoPlayer
  
  // Check network status before playing video
  const checkNetworkAndPlay = async () => {
    try {
      // Simple network check by making a small request
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 3000); // 3 second timeout
      
      const response = await fetch('https://cloudinary.com/favicon.ico', { 
        method: 'HEAD',
        signal: controller.signal,
        headers: {
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache'
        }
      }).catch(() => ({ ok: false }));
      
      clearTimeout(timeoutId);
      
      if (response.ok) {
        console.log(`Network check passed for post ${post.id}`);
        // Network seems good, try to play
        if (videoPlayer && activeVideoId === post.id) {
          try {
            videoPlayer.play();
            setPlaying(true);
            // Clear any previous errors since playback started successfully
            if (videoError) {
              setVideoError(false);
              trackVideoError(post.id, false);
            }
          } catch (playError) {
            console.error(`Error playing video after network check for post ${post.id}:`, playError);
            trackVideoError(post.id, {
              hasError: true,
              timestamp: Date.now(),
              errorMessage: playError?.message || 'Error playing after network check',
              url: post.media_url
            });
          }
        }
        return true;
      } else {
        console.warn(`Network check failed with status ${response.status || 'unknown'} for post ${post.id}`);
        // Still try to play despite network issues
        if (videoPlayer && activeVideoId === post.id) {
          try {
            videoPlayer.play();
            setPlaying(true);
          } catch (playError) {
            console.error(`Error playing video after failed network check for post ${post.id}:`, playError);
            trackVideoError(post.id, {
              hasError: true,
              timestamp: Date.now(),
              errorMessage: `Network issues: ${playError?.message || 'Unknown error'}`,
              url: post.media_url
            });
          }
        }
        return false;
      }
    } catch (error) {
      console.warn(`Network check error for post ${post.id}:`, error);
      // Still try to play despite network issues
      if (videoPlayer && activeVideoId === post.id) {
        try {
          videoPlayer.play();
          setPlaying(true);
        } catch (playError) {
          console.error(`Error playing video after network check error for post ${post.id}:`, playError);
          trackVideoError(post.id, {
            hasError: true,
            timestamp: Date.now(),
            errorMessage: `Network error: ${error?.message}, Play error: ${playError?.message || 'Unknown error'}`,
            url: post.media_url
          });
        }
      }
      return false;
    }
  };
  
  // Check if video URL is valid and accessible
  const checkVideoUrl = async (url) => {
    if (!url) {
      console.error('Attempted to check null or undefined video URL');
      return false;
    }
    
    try {
      console.log(`Checking video URL for post ${post.id}: ${url}`);
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
      
      // Try a HEAD request first (faster)
      try {
        const response = await fetch(url, {
          method: 'HEAD',
          signal: controller.signal,
          headers: {
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
          }
        });
        
        clearTimeout(timeoutId);
        
        if (response.ok) {
          console.log(`Video URL is valid (HEAD): ${url}`);
          return true;
        } else if (response.status === 403 || response.status === 405) {
          // Some servers don't allow HEAD requests, try GET instead
          console.log(`HEAD request failed with ${response.status}, trying GET request`);
          return await checkVideoUrlWithGet(url);
        } else {
          console.warn(`Video URL returned status ${response.status}: ${url}`);
          return false;
        }
      } catch (headError) {
        // Check if the error is an abort error, which means the request timed out
        if (headError.name === 'AbortError') {
          console.warn(`HEAD request timed out for ${url}, considering as invalid`);
          return false;
        }
        console.warn(`HEAD request failed, trying GET: ${headError.message}`);
        return await checkVideoUrlWithGet(url);
      }
    } catch (error) {
      console.error(`Error checking video URL ${url}:`, error);
      return false;
    }
  };
  
  // Helper function to check URL with GET request
  const checkVideoUrlWithGet = async (url) => {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
      
      // Try a GET request with range header to minimize data transfer
      const response = await fetch(url, {
        method: 'GET',
        signal: controller.signal,
        headers: {
          'Range': 'bytes=0-1024', // Only request first KB
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache'
        }
      });
      
      clearTimeout(timeoutId);
      
      if (response.ok || response.status === 206) { // 206 is Partial Content
        console.log(`Video URL is valid (GET): ${url}`);
        return true;
      } else {
        console.warn(`Video URL GET request returned status ${response.status}: ${url}`);
        return false;
      }
    } catch (error) {
      // Check if the error is an abort error, which means the request timed out
      if (error.name === 'AbortError') {
        console.error(`GET request timed out for video URL ${url}:`, error);
        return false;
      }
      console.error(`Error in GET check for video URL ${url}:`, error);
      return false;
    }
  };
  
  // Auto-play video when it becomes visible in the viewport
  useEffect(() => {
    let isMounted = true;
    const handleVideoStateChange = async () => {
      if (videoPlayer) {
        if (activeVideoId === post.id) {
          try {
            // Check if this video has had errors before
            if (hasVideoError(post.id)) {
              console.log(`Post ${post.id} has previous errors, validating URL before playing`);
              const isValid = await checkVideoUrl(post.media_url);
              if (!isValid) {
                console.warn(`URL validation failed for previously errored video ${post.id}, not attempting playback`);
                setVideoError(true);
                setLoading(false);
                return;
              }
              console.log(`URL validation passed for previously errored video ${post.id}, attempting to play`);
              // URL is valid, clear the error
              trackVideoError(post.id, false);
            }
            
            // Check network before playing
            const hasNetwork = await checkNetworkAndPlay();
            
            if (!hasNetwork) {
              console.warn(`Network connection appears unstable for post ${post.id}`);
              // Still try to play, but log the warning
            }
            
            setPlaying(true);
            videoPlayer.play();
          } catch (error) {
            console.error(`Error playing video for post ${post.id}:`, error);
            setVideoError(true);
            setLoading(false);
            trackVideoError(post.id, {
              hasError: true,
              timestamp: Date.now(),
              errorMessage: error?.message || 'Error during video playback',
              url: post.media_url
            });
          }
        } else {
          try {
            // Only pause if this video is not the active one
            videoPlayer.pause();
          } catch (error) {
            console.error(`Error pausing video for post ${post.id}:`, error);
          }
          if (isMounted) setPlaying(false);
        }
      }
    };
    handleVideoStateChange();
    return () => {
      isMounted = false;
      if (videoPlayer) {
        try {
          videoPlayer.pause();
        } catch (err) {
          console.warn(`Error pausing video on unmount for post ${post.id}:`, err);
        }
      }
    };
  }, [post.id, activeVideoId, isFullscreenMode, hasVideoError, videoPlayer]);
  
  // Effect to handle fullscreen mode changes
  useEffect(() => {
    if (isFullscreenMode && !fullscreen && playing) {
      // If we're in fullscreen mode but this video isn't the fullscreen one and it's playing, pause it
      setPlaying(false);
      if (videoPlayer) {
        try {
          console.log(`Pausing video for post ${post.id} due to fullscreen mode change`);
          videoPlayer.pause();
        } catch (error) {
          console.warn(`Error pausing video for post ${post.id} during fullscreen change:`, error);
        }
      }
    }
  }, [isFullscreenMode, fullscreen, playing, post.id, videoPlayer]);
  
  // Lazy load video only when it's visible
  useEffect(() => {
    if (post.type === 'video' && post.media_url) {
      // Track if this effect is still relevant
      let isMounted = true;
      let playbackAttempted = false;
      
      // When this post becomes the active video, mark it as visible
      if (activeVideoId === post.id) {
        // Only log once when becoming visible
        if (!isVideoVisible(post.id)) {
          console.log(`Post ${post.id} is now visible and active`);
          addVisibleVideo(post.id);
        }
        
        const preloadAndPlay = async () => {
          // Prevent multiple playback attempts for the same video
          if (playbackAttempted) return;
          playbackAttempted = true;
          
          try {
            // Check if this video has had errors before
            if (hasVideoError(post.id)) {
              console.log(`Post ${post.id} has previous errors, validating URL before loading`);
              const isValid = await checkVideoUrl(post.media_url);
              if (!isValid) {
                console.warn(`URL validation failed for previously errored video ${post.id}, not attempting playback`);
                if (isMounted) {
                  setVideoError(true);
                  setLoading(false);
                }
                return;
              }
              console.log(`URL validation passed for previously errored video ${post.id}, attempting to load`);
              // URL is valid, clear the error
              trackVideoError(post.id, false);
            }
            
            // VideoPlayer from expo-video automatically preloads when created
            // We just need to ensure it's not playing until needed
            if (videoPlayer && !playing) {
              // Check network before playing
              const hasNetwork = await checkNetworkAndPlay();
              
              if (!hasNetwork) {
                console.warn(`Network connection appears unstable for post ${post.id}`);
                // Still try to play, but log the warning
              }
              
              if (isMounted && activeVideoId === post.id) {
                setPlaying(true);
                videoPlayer.play();
                console.log(`Video started playing for post ${post.id}`);
                
                // If playback started successfully but we had previous errors, clear them
                if (hasVideoError(post.id)) {
                  trackVideoError(post.id, false);
                }
              }
            }
          } catch (error) {
            console.error(`Error loading/playing video for post ${post.id}:`, error);
            if (isMounted) {
              setVideoError(true);
              setLoading(false);
            }
            trackVideoError(post.id, {
              hasError: true,
              timestamp: Date.now(),
              errorMessage: `Load/play error: ${error?.message || 'Unknown error'}`,
              url: post.media_url
            });
          }
        };
        
        // Only attempt loading if videoPlayer is available and not already playing
        if (videoPlayer && !playing) {
          preloadAndPlay();
        }
      } else {
        // When this post is no longer the active video, mark it as not visible
        if (isVideoVisible(post.id)) {
          console.log(`Post ${post.id} is no longer visible or active`);
          removeVisibleVideo(post.id);
          
          // Pause the video if it's playing
          if (playing && videoPlayer) {
            try {
              videoPlayer.pause();
              if (isMounted) setPlaying(false);
              console.log(`Video paused for post ${post.id} as it's no longer visible`);
            } catch (error) {
              console.warn(`Error pausing video for post ${post.id}:`, error);
            }
          }
        }
      }
      
      return () => {
        isMounted = false;
      };
    }
  }, [post.id, post.media_url, post.type, activeVideoId, hasVideoError, isVideoVisible, videoPlayer, playing]);

  
  // Effect to pass posts data to navigation state for ShortsScreen
  useEffect(() => {
    if (navigation) {
      const currentRoute = navigation.getState().routes.find(route => route.name === 'Home');
      if (currentRoute) {
        navigation.setParams({
          ...currentRoute.params,
          data: currentRoute.params?.data || [post]
        });
      }
    }
  }, [navigation, post]);
  
  // Effect to ensure only one video instance is playing at a time
  useEffect(() => {
    // When component unmounts or when fullscreen state changes, ensure video is paused
    return () => {
      if (videoPlayer) {
        try {
          console.log(`Pausing video for post ${post.id} on cleanup`);
          videoPlayer.pause();
        } catch (error) {
          console.warn(`Error pausing video for post ${post.id} on cleanup:`, error);
        }
      }
    };
  }, [fullscreen, post.id, videoPlayer]);

  const [showLikesModal, setShowLikesModal] = useState(false);
  const [showCommentModal, setShowCommentModal] = useState(false);
  const [showEditModal, setShowEditModal] = useState(false);
  const [editCaption, setEditCaption] = useState(post.caption || '');
  const [likesList, setLikesList] = useState([]);
  const [loadingLikes, setLoadingLikes] = useState(false);
  const [currentUser, setCurrentUser] = useState(null);

  useEffect(() => {
    const getCurrentUser = async () => {
      const { data: { user } } = await supabase.auth.getUser();
      setCurrentUser(user);
    };
    getCurrentUser();
  }, []);

  const handleLike = async () => {
    try {
      const { isLiked: liked, likesCount: newCount } = await PostsService.toggleLike(post.id);
      setIsLiked(liked);
      setLikesCount(newCount);
    } catch (error) {
      console.error('Error toggling like:', error);
      Alert.alert('Error', 'Failed to update like');
    }
  };

  const handleShowLikes = async () => {
    try {
      setLoadingLikes(true);
      const { data, error } = await supabase
        .from('post_likes')
        .select(`
          user_id,
          profiles:user_id (username, avatar_url)
        `)
        .eq('post_id', post.id);

      if (error) throw error;
      setLikesList(data);
      setShowLikesModal(true);
    } catch (error) {
      console.error('Error fetching likes:', error);
      Alert.alert('Error', 'Failed to load likes');
    } finally {
      setLoadingLikes(false);
    }
  };

  const handleComment = () => {
    setShowCommentModal(true);
  };

  const handleEdit = async () => {
    try {
      await PostsService.editPost(post.id, editCaption);
      post.caption = editCaption;
      setShowEditModal(false);
      Alert.alert('Success', 'Post updated successfully');
    } catch (error) {
      console.error('Error updating post:', error);
      Alert.alert('Error', 'Failed to update post');
    }
  };

  const handleDelete = async () => {
    Alert.alert(
      'Delete Post',
      'Are you sure you want to delete this post?',
      [
        {
          text: 'Cancel',
          style: 'cancel'
        },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: async () => {
            try {
              await PostsService.deletePost(post.id);
              // Trigger parent component update
              if (onOptionsPress) {
                onOptionsPress({ type: 'delete', postId: post.id });
              }
              // Close any open modals
              setShowLikesModal(false);
              setShowCommentModal(false);
              setShowEditModal(false);
            } catch (error) {
              console.error('Error deleting post:', error);
              Alert.alert('Error', 'Failed to delete post');
            }
          }
        }
      ]
    );
  };
  
  const handleCloseCommentModal = () => {
    setShowCommentModal(false);
  };

  // Handle share functionality
  const handleShare = async () => {
    try {
      const result = await Share.share({
        message: `Check out this ${post.type === 'video' ? 'video' : 'post'} from ${post.profiles?.username || 'a user'}!\n\n${post.caption || ''}\n\nOpen the app to view.`,
        url: post.media_url, // This may not work on all platforms
        title: `Share this ${post.type === 'video' ? 'video' : 'post'}`
      });
      
      if (result.action === Share.sharedAction) {
        if (result.activityType) {
          // shared with activity type of result.activityType
          console.log('Shared with activity type:', result.activityType);
        } else {
          // shared
          console.log('Shared successfully');
        }
      } else if (result.action === Share.dismissedAction) {
        // dismissed
        console.log('Share dismissed');
      }
    } catch (error) {
      Alert.alert('Error', `Could not share this ${post.type === 'video' ? 'video' : 'post'}`);
      console.error('Error sharing:', error);
    }
  };

  return (
    <>
      <LinearGradient
        colors={['#1a1a3a', '#0d0d2a']}
        style={styles.container}
      >
        {/* Post Header */}
        <View style={styles.header}>
          <TouchableOpacity style={styles.headerLeft} onPress={handleProfilePress}>
            <LinearGradient colors={['#ff00ff', '#00ffff']} style={styles.avatarBorder}>
              <Image
                source={{ uri: getAvatarUrl() }}
                style={styles.avatar}
                defaultSource={require('../../assets/defaultavatar.png')}
              />
            </LinearGradient>
            <View style={styles.headerInfo}>
              <Text style={styles.username}>{post?.profiles?.username || 'Anonymous User'}</Text>
              <Text style={styles.timestamp}>
                {new Date(post?.created_at || Date.now()).toLocaleDateString()}
              </Text>
            </View>
          </TouchableOpacity>
          {currentUser && currentUser.id === post?.user_id && (
            <TouchableOpacity 
              style={styles.optionsButton} 
              onPress={() => {
                Alert.alert(
                  'Post Options',
                  'What would you like to do?',
                  [
                    { text: 'Edit Caption', onPress: () => setShowEditModal(true) },
                    { text: 'Delete Post', onPress: handleDelete, style: 'destructive' },
                    { text: 'Cancel', style: 'cancel' }
                  ]
                );
              }}
            >
              <Ionicons name="ellipsis-vertical" size={20} color="#fff" />
            </TouchableOpacity>
          )}
        </View>

        {/* Post Caption */}
        {post.caption && (
          <View style={styles.captionContainer}>
            <Text style={styles.caption}>
              {post.caption.split(/(https?:\/\/[^\s]+)/g).map((part, index) => {
                if (part.match(/^https?:\/\//)) {
                  return (
                    <TouchableOpacity key={index} onPress={() => Linking.openURL(part)}>
                      <Text style={styles.link}>{part}</Text>
                    </TouchableOpacity>
                  );
                }
                return part;
              })}
            </Text>
          </View>
        )}



        {/* Post Media */}
        {post.media_url && (
          <View style={styles.mediaContainer}>
            {post.type === 'video' ? (
              <TouchableWithoutFeedback 
                onPress={handleVideoPress}
                onPressIn={handleTouchStart}
                onPressOut={handleTouchEnd}
              >
                <View style={styles.videoContainer}>
                  {loading && (
                    <View style={styles.loadingContainer}>
                      <ActivityIndicator size="large" color="#ff00ff" />
                      <Text style={styles.loadingText}>Loading video...</Text>
                    </View>
                  )}

                  <VideoView
                    player={videoPlayer}
                    style={styles.media}
                    resizeMode="cover"
                    allowsFullscreen={false}
                    allowsPictureInPicture={false}
                  />
                  
                  {showPauseIcon && (
                    <Animated.View style={[styles.videoOverlay, { opacity: fadeAnim }]}>
                      <Ionicons name="pause" size={60} color="#ffffff" />
                    </Animated.View>
                  )}

                  {/* Video controls removed as per user request */}

                  {videoError && (
                    <TouchableOpacity 
                      style={styles.errorContainer}
                      onPress={async () => {
                        // Reset error state
                        setVideoError(false);
                        setLoading(true);
                        
                        // Clear the error in the context
                        trackVideoError(post.id, false);
                        
                        // Check if the URL is valid before attempting to reload
                        const isUrlValid = await checkVideoUrl(post.media_url);
                        if (!isUrlValid) {
                          console.warn(`Video URL still invalid for post ${post.id}: ${post.media_url}`);
                          setVideoError(true);
                          setLoading(false);
                          trackVideoError(post.id, {
                            hasError: true,
                            timestamp: Date.now(),
                            errorMessage: 'URL validation failed on retry',
                            url: post.media_url
                          });
                          return;
                        }
                        
                        // Add a small delay before retry to ensure clean state
                        setTimeout(() => {
                          if (videoPlayer) {
                            try {
                              // Replace the source to force reload
                              videoPlayer.replace(post.media_url);
                              
                              if (activeVideoId === post.id) {
                                videoPlayer.play();
                                setPlaying(true);
                                console.log(`Successfully reloaded and playing video for post ${post.id}`);
                              }
                            } catch (err) {
                              console.error(`Error reloading video for post ${post.id}:`, err);
                              setVideoError(true);
                              setLoading(false);
                              trackVideoError(post.id, {
                                hasError: true,
                                timestamp: Date.now(),
                                errorMessage: err?.message || 'Error during video reload',
                                url: post.media_url
                              });
                            }
                          }
                        }, 500);
                      }}
                    >
                      <Ionicons name="alert-circle" size={30} color="#ff00ff" />
                      <Text style={styles.errorText}>Video unavailable</Text>
                      <Text style={styles.errorSubText}>Tap to retry</Text>
                    </TouchableOpacity>
                  )}
                </View>
              </TouchableWithoutFeedback>
            ) : (
              <View style={styles.imageContainer}>
                <Image
                  source={{ uri: post.media_url }}
                  style={styles.media}
                  resizeMode="cover"
                  onLoadStart={() => setImageLoaded(false)}
                  onLoad={() => setImageLoaded(true)}
                />
                {!imageLoaded && (
                  <View style={styles.loadingContainer}>
                    <ActivityIndicator size="large" color="#ff00ff" />
                    <Text style={styles.loadingText}>Loading image...</Text>
                  </View>
                )}
              </View>
            )}
          </View>
        )}

        {/* Post Actions */}
        <LinearGradient colors={['rgba(26, 26, 58, 0.8)', 'rgba(13, 13, 42, 0.9)']} style={styles.actions}>
          <TouchableOpacity style={styles.actionButton} onPress={handleLike}>
            <LinearGradient colors={isLiked ? ['#ff00ff', '#9900ff'] : ['transparent', 'transparent']} style={isLiked ? styles.likedIconBackground : {}}>
              <Ionicons name={isLiked ? 'heart' : 'heart-outline'} size={26} color={isLiked ? '#fff' : '#e0e0ff'} />
            </LinearGradient>
            <Text style={[styles.actionText, isLiked && styles.likedText]}>
              {likesCount}
            </Text>
          </TouchableOpacity>

          <TouchableOpacity style={styles.actionButton} onPress={handleComment}>
            <Ionicons name="chatbubble-outline" size={24} color="#e0e0ff" />
            <Text style={styles.actionText}>
              {commentsCount}
            </Text>
          </TouchableOpacity>

          <TouchableOpacity style={styles.actionButton} onPress={handleShare}>
            <Ionicons name="share-social-outline" size={24} color="#e0e0ff" />
          </TouchableOpacity>
        </LinearGradient>


        {/* Likes Modal */}
        <Modal
          visible={showLikesModal}
          transparent={true}
          animationType="slide"
          onRequestClose={() => setShowLikesModal(false)}
        >
          <View style={styles.modalContainer}>
            <View style={styles.modalContent}>
              <View style={styles.modalHeader}>
                <Text style={styles.modalTitle}>Likes</Text>
                <TouchableOpacity onPress={() => setShowLikesModal(false)}>
                  <Ionicons name="close" size={24} color="#fff" />
                </TouchableOpacity>
              </View>
              
              {loadingLikes ? (
                <ActivityIndicator size="large" color="#ff00ff" style={styles.loadingIndicator} />
              ) : (
                <ScrollView style={styles.likesList}>
                  {likesList.map((like, index) => (
                    <TouchableOpacity 
                      key={index}
                      style={styles.likeItem}
                      onPress={() => {
                        setShowLikesModal(false);
                        navigation.navigate('UserProfileScreen', { userId: like.user_id });
                      }}
                    >
                      <Image 
                        source={{ uri: like.profiles.avatar_url || 'https://via.placeholder.com/150' }}
                        style={styles.likeAvatar}
                      />
                      <Text style={styles.likeUsername}>{like.profiles.username}</Text>
                    </TouchableOpacity>
                  ))}
                </ScrollView>
              )}
            </View>
          </View>
        </Modal>
      </LinearGradient>

      {/* Comment Modal */}
      <CommentScreen 
        visible={showCommentModal} 
        onClose={handleCloseCommentModal} 
        postId={post.id} 
      />

      {/* Edit Caption Modal */}
      <Modal
        visible={showEditModal}
        transparent={true}
        animationType="slide"
        onRequestClose={() => setShowEditModal(false)}
      >
        <View style={styles.modalContainer}>
          <View style={styles.modalContent}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>Edit Caption</Text>
              <TouchableOpacity onPress={() => setShowEditModal(false)}>
                <Ionicons name="close" size={24} color="#fff" />
              </TouchableOpacity>
            </View>
            
            <TextInput
              style={styles.editInput}
              value={editCaption}
              onChangeText={setEditCaption}
              multiline
              placeholder="Write a caption..."
              placeholderTextColor="#666"
            />
            
            <TouchableOpacity 
              style={styles.editButton}
              onPress={handleEdit}
            >
              <Text style={styles.editButtonText}>Save Changes</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>

      {/* Fullscreen Video */}
      {fullscreen && (
        <Modal
          visible={fullscreen}
          transparent={false}
          animationType="fade"
          onRequestClose={handleFullscreenClose}
        >
          <LinearGradient
            colors={['#1a1a3a', '#0d0d2a']}
            style={styles.fullscreenContainer}
          >
            <VideoView
            player={videoPlayer}
            style={styles.fullscreenVideo}
            resizeMode="cover"
            allowsFullscreen={true}
            allowsPictureInPicture={true}
            />

            {/* Fullscreen video controls */}
            {fullscreen && (
              <LinearGradient
                colors={['rgba(0,0,0,0.9)', 'rgba(0,0,0,0.9)']}
                style={styles.fullscreenOverlay}
              >
                {/* Video controls */}
                {fullscreen && (
                  <View>
                    {/* Top controls */}
                    <LinearGradient
                      colors={['rgba(0,0,0,0.7)', 'transparent']}
                      style={styles.fullscreenTopControls}
                    >
                      <TouchableOpacity onPress={handleFullscreenClose}>
                        <Ionicons name="arrow-back" size={28} color="#fff" />
                      </TouchableOpacity>
                    </LinearGradient>
                    
                    {/* Bottom controls */}
                    <LinearGradient
                      colors={['transparent', 'rgba(0,0,0,0.7)']}
                      style={styles.fullscreenBottomControls}
                    >
                      {/* Simple play/pause button */}
                      <View style={styles.fullscreenControlsRow}>
                        <TouchableOpacity style={styles.fullscreenPlayPauseButton} onPress={() => setPlaying(!playing)}>
                          <LinearGradient
                            colors={['#ff00ff', '#9900ff']}
                            style={styles.fullscreenPlayButtonGradient}
                          >
                            <Ionicons name={playing ? 'pause' : 'play'} size={28} color="#fff" />
                          </LinearGradient>
                        </TouchableOpacity>
                      </View>
                    </LinearGradient>
                  </View>
                )}
              </LinearGradient>
            )}
          </LinearGradient>
        </Modal>
      )}
    </>
  );
};

const styles = StyleSheet.create({
  fullscreenOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'space-between',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  editInput: {
    backgroundColor: '#1a1a3a',
    borderRadius: 10,
    padding: 15,
    color: '#fff',
    fontSize: 16,
    minHeight: 100,
    textAlignVertical: 'top',
    marginVertical: 15,
  },
  editButton: {
    backgroundColor: '#ff00ff',
    borderRadius: 25,
    padding: 15,
    alignItems: 'center',
    marginTop: 10,
  },
  editButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  modalContainer: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'flex-end',
  },
  modalContent: {
    backgroundColor: '#1a1a3a',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    minHeight: '50%',
    maxHeight: '80%',
    padding: 20,
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#fff',
  },
  link: {
    color: '#00ffff',
    textDecorationLine: 'underline',
  },
  loadingIndicator: {
    marginTop: 20,
  },
  likesList: {
    flex: 1,
  },
  likeItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 10,
  },
  likeAvatar: {
    width: 40,
    height: 40,
    borderRadius: 20,
    marginRight: 10,
  },
  likeUsername: {
    fontSize: 16,
    color: '#fff',
  },
  actions: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'center',
    paddingVertical: 10,
    borderTopWidth: 0.5,
    borderTopColor: 'rgba(255, 255, 255, 0.1)',
  },
  likedIconBackground: {
    padding: 8,
    borderRadius: 20,
  },
  likedText: {
    color: '#ff00ff',
  },
  actionButtons: {
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
    paddingHorizontal: 15,
    paddingVertical: 10,
    gap: 20,
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  actionText: {
    color: '#ffffff',
    fontSize: 14,
    fontWeight: '600',
  },
  iconBackground: {
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 5,
  },
  container: { marginBottom: 20, borderRadius: 10, overflow: 'hidden' },
  header: { flexDirection: 'row', alignItems: 'center', padding: 10, justifyContent: 'space-between' },
  headerLeft: { flexDirection: 'row', alignItems: 'center' },
  headerInfo: { marginLeft: 10 },
  username: { fontSize: 16, fontWeight: 'bold', color: '#fff' },
  timestamp: { fontSize: 12, color: '#aaa' },
  optionsButton: { padding: 5 },
  avatarBorder: { width: 50, height: 50, borderRadius: 25, padding: 2 },
  avatar: { width: 46, height: 46, borderRadius: 23 },
  captionContainer: { padding: 10 },
  caption: { color: '#ddd' },
  mediaContainer: { width: '100%', aspectRatio: 1 },
  media: { width: '100%', height: '100%', backgroundColor: '#000', objectFit: 'cover' },
  videoContainer: { width: '100%', height: '100%', backgroundColor: '#000', justifyContent: 'center', alignItems: 'center', overflow: 'hidden' },
  loadingContainer: { ...StyleSheet.absoluteFill, justifyContent: 'center', alignItems: 'center' },
  loadingText: { marginTop: 5, color: '#ff00ff' },
  actions: { flexDirection: 'row', padding: 10, justifyContent: 'space-around' },
  actionButton: { alignItems: 'center' },
  actionText: { marginTop: 2, color: '#e0e0ff', fontSize: 12 },
  likedIconBackground: { borderRadius: 20, padding: 5 },
  likedText: { color: '#ff00ff' },
  timeContainer: { flexDirection: 'row', justifyContent: 'space-between', marginBottom: 5 },
  timeText: { color: '#fff', fontSize: 12, fontWeight: '500' },
  // Video control styles removed
  videoOverlay: { ...StyleSheet.absoluteFill, justifyContent: 'center', alignItems: 'center', backgroundColor: 'rgba(0,0,0,0.3)' },
  playButton: { width: 60, height: 60, borderRadius: 30, overflow: 'hidden' },
  playButtonGradient: { flex: 1, justifyContent: 'center', alignItems: 'center', borderRadius: 30 },
  errorContainer: { ...StyleSheet.absoluteFill, justifyContent: 'center', alignItems: 'center', backgroundColor: 'rgba(0,0,0,0.6)' },
  errorText: { color: '#fff', marginTop: 10 },
  errorSubText: { color: '#ccc', fontSize: 12 },
  
  // Fullscreen styles
  fullscreenContainer: { 
    flex: 1, 
    backgroundColor: '#000',
    justifyContent: 'center',
    alignItems: 'center',
    overflow: 'hidden'
  },
  fullscreenVideo: { 
    width: '100%',
    height: '100%',
    position: 'absolute'
  },
  fullscreenTopControls: { 
    position: 'absolute', 
    top: 0, 
    left: 0,
    right: 0,
    height: 100, 
    paddingTop: 40,
    paddingHorizontal: 20
  },
  fullscreenBottomControls: { 
    position: 'absolute', 
    bottom: 0, 
    left: 0,
    right: 0,
    paddingBottom: 30,
    paddingHorizontal: 20,
    paddingTop: 50
  },
  fullscreenTimeContainer: { 
    flexDirection: 'row', 
    justifyContent: 'space-between', 
    marginBottom: 10,
    paddingHorizontal: 5
  },
  // Fullscreen seekbar styles removed
  fullscreenSeekbarTouchable: {
    position: 'absolute',
    width: '100%',
    height: 30,
    marginBottom: 20 // Increased bottom margin to prevent collision with buttons
  },
  // Fullscreen seekbar touch styles removed
  fullscreenControlsRow: { 
    flexDirection: 'row', 
    justifyContent: 'center', 
    alignItems: 'center', 
    paddingHorizontal: 20
  },
  fullscreenControlButton: { 
    padding: 12,
    backgroundColor: 'rgba(0,0,0,0.3)',
    borderRadius: 30
  },
  fullscreenPlayPauseButton: { 
    width: 60, 
    height: 60, 
    borderRadius: 30, 
    overflow: 'hidden', 
    justifyContent: 'center', 
    alignItems: 'center',
    marginHorizontal: 20
  },
  fullscreenPlayButtonGradient: { 
    width: '100%',
    height: '100%',
    justifyContent: 'center', 
    alignItems: 'center', 
    borderRadius: 30 
  },
  closeButton: { 
    position: 'absolute', 
    top: 0, 
    right: 0, 
    padding: 15,
    zIndex: 10 
  },
});

export default PostItem;















import React, { createContext, useState, useContext, useRef, useEffect } from 'react';

const VideoContext = createContext();

export const VideoProvider = ({ children }) => {
  const [activeVideoId, setActiveVideoId] = useState(null);
  const [isFullscreenMode, setIsFullscreenMode] = useState(false);
  const [videoErrors, setVideoErrors] = useState({});
  const [visibleVideos, setVisibleVideos] = useState(new Set());
  const previousActiveVideo = useRef(null);

  // Set the currently playing video
  const setActiveVideo = (videoId) => {
    // Store the previous active video before changing
    previousActiveVideo.current = activeVideoId;
    setActiveVideoId(videoId);
    
    // Add to visible videos set
    if (videoId) {
      setVisibleVideos(prev => {
        const newSet = new Set(prev);
        newSet.add(videoId);
        return newSet;
      });
    }
  };

  // Clear the currently playing video
  const clearActiveVideo = () => {
    previousActiveVideo.current = activeVideoId;
    setActiveVideoId(null);
  };

  // Toggle fullscreen mode
  const setFullscreen = (isFullscreen) => {
    setIsFullscreenMode(isFullscreen);
  };

  // Restore previous active video
  const restorePreviousVideo = () => {
    if (previousActiveVideo.current) {
      setActiveVideoId(previousActiveVideo.current);
      return previousActiveVideo.current;
    }
    return null;
  };

  // Track video errors
  const trackVideoError = (videoId, hasError = true) => {
    setVideoErrors(prev => ({
      ...prev,
      [videoId]: hasError
    }));
  };
  
  // Check if a video has errors
  const hasVideoError = (videoId) => {
    return videoErrors[videoId] || false;
  };
  
  // Clear all video errors
  const clearAllVideoErrors = () => {
    setVideoErrors({});
  };
  
  // Add a video to visible videos set with debounce to prevent rapid changes
  const lastVisibilityChange = useRef({});
  const debounceTimeMs = 500; // Minimum time between visibility changes for the same video
  
  const addVisibleVideo = (videoId) => {
    if (!videoId) return;
    
    const now = Date.now();
    const lastChange = lastVisibilityChange.current[videoId] || 0;
    
    // Skip if this video's visibility was updated too recently
    if (now - lastChange < debounceTimeMs) return;
    
    // Update the last change timestamp
    lastVisibilityChange.current[videoId] = now;
    
    // Only add if not already in the set to avoid unnecessary re-renders
    if (!visibleVideos.has(videoId)) {
      setVisibleVideos(prev => {
        const newSet = new Set(prev);
        newSet.add(videoId);
        return newSet;
      });
    }
  };
  
  // Remove a video from visible videos set with debounce
  const removeVisibleVideo = (videoId) => {
    if (!videoId) return;
    
    const now = Date.now();
    const lastChange = lastVisibilityChange.current[videoId] || 0;
    
    // Skip if this video's visibility was updated too recently
    if (now - lastChange < debounceTimeMs) return;
    
    // Update the last change timestamp
    lastVisibilityChange.current[videoId] = now;
    
    // Only remove if it's in the set to avoid unnecessary re-renders
    if (visibleVideos.has(videoId)) {
      setVisibleVideos(prev => {
        const newSet = new Set(prev);
        newSet.delete(videoId);
        return newSet;
      });
      
      // If the active video is no longer visible, clear it after a short delay
      // to prevent flickering when scrolling quickly
      if (activeVideoId === videoId) {
        setTimeout(() => {
          // Only clear if it's still the active video after the delay
          if (activeVideoId === videoId) {
            clearActiveVideo();
          }
        }, 300);
      }
    }
  };
  
  // Check if a video is visible
  const isVideoVisible = (videoId) => {
    return videoId ? visibleVideos.has(videoId) : false;
  };
  
  // Periodically clean up old video errors
  useEffect(() => {
    const cleanupInterval = setInterval(() => {
      // Remove errors older than 10 minutes
      const now = Date.now();
      const updatedErrors = { ...videoErrors };
      let hasChanges = false;
      
      Object.keys(updatedErrors).forEach(videoId => {
        if (updatedErrors[videoId].timestamp && (now - updatedErrors[videoId].timestamp > 10 * 60 * 1000)) {
          delete updatedErrors[videoId];
          hasChanges = true;
        }
      });
      
      if (hasChanges) {
        setVideoErrors(updatedErrors);
      }
    }, 5 * 60 * 1000); // Run every 5 minutes
    
    return () => clearInterval(cleanupInterval);
  }, [videoErrors]);
  
  return (
    <VideoContext.Provider 
      value={{
        activeVideoId,
        isFullscreenMode,
        videoErrors,
        visibleVideos,
        setActiveVideo,
        clearActiveVideo,
        setFullscreen,
        restorePreviousVideo,
        trackVideoError,
        hasVideoError,
        clearAllVideoErrors,
        addVisibleVideo,
        removeVisibleVideo,
        isVideoVisible
      }}
    >
      {children}
    </VideoContext.Provider>
  );
};

// Custom hook to use the video context
export const useVideo = () => useContext(VideoContext);












import React, { useState, useRef, useEffect } from 'react';
import { View, FlatList, Dimensions, StyleSheet, TouchableOpacity, Text, ActivityIndicator, Alert, Share, Animated } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useNavigation } from '@react-navigation/native';
import { Video } from 'expo-av';
import { LinearGradient } from 'expo-linear-gradient';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { useVideo } from '../context/VideoContext';
import { supabase } from '../config/supabase';
import { PostsService } from '../services/PostsService';

const { width, height } = Dimensions.get('window');

const ShortsScreen = ({ route }) => {
  const { posts: routePosts, initialIndex = 0, userId } = route.params;
  const navigation = useNavigation();
  const insets = useSafeAreaInsets();
  const flatListRef = useRef(null);
  const videoRefs = useRef({});
  const [currentIndex, setCurrentIndex] = useState(initialIndex);
  const [isPlaying, setIsPlaying] = useState(true); // Default to playing
  const [progress, setProgress] = useState(0);
  const [duration, setDuration] = useState(0);
  const [currentTime, setCurrentTime] = useState(0);
  const [showControls, setShowControls] = useState(false);
  const [posts, setPosts] = useState(routePosts || []);
  const [loading, setLoading] = useState(!routePosts);
  const [userProfile, setUserProfile] = useState(null);
  const [showPauseIcon, setShowPauseIcon] = useState(false);
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const controlsTimeout = useRef(null);
  const touchTimer = useRef(null);
  const isTouchHolding = useRef(false);
  const pauseIconTimeout = useRef(null);
  const { setFullscreen } = useVideo();
  const isUserSpecificView = !!userId;
  
  // Set fullscreen mode when component mounts
  useEffect(() => {
    setFullscreen(true);
    return () => setFullscreen(false);
  }, []);
  
  // Load user shorts if userId is provided
  useEffect(() => {
    if (userId && !routePosts) {
      loadUserProfile();
      loadUserShorts();
    }
  }, [userId]);

  // Load user profile
  const loadUserProfile = async () => {
    try {
      const { data, error } = await supabase
        .from('profiles')
        .select('*')
        .eq('id', userId)
        .single();
        
      if (error) throw error;
      setUserProfile(data);
    } catch (error) {
      console.error('Error loading user profile:', error);
    }
  };

  // Load user shorts
  const loadUserShorts = async () => {
    try {
      setLoading(true);
      // Get video posts for specific user
      const { data, error } = await supabase
        .from('posts')
        .select(`
          *,
          profiles:user_id(*),
          likes:post_likes(count),
          comments:post_comments(count),
          user_likes:post_likes(user_id)
        `)
        .eq('user_id', userId)
        .eq('type', 'video')
        .order('created_at', { ascending: false });
        
      if (error) throw error;
      
      // Check if current user has liked each post
      const { data: { user } } = await supabase.auth.getUser();
      const shortsWithLikeStatus = data.map(post => ({
        ...post,
        is_liked: post.user_likes?.some(like => like.user_id === user.id) || false
      }));
      
      setPosts(shortsWithLikeStatus);
    } catch (error) {
      console.error('Error loading user shorts:', error);
    } finally {
      setLoading(false);
    }
  };

  // Scroll to initial index when component mounts
  useEffect(() => {
    if (flatListRef.current && initialIndex > 0) {
      flatListRef.current.scrollToIndex({
        index: initialIndex,
        animated: false,
      });
    }
  }, [initialIndex]);

  // Format time in mm:ss format
  const formatTime = (timeMillis) => {
    const totalSeconds = Math.floor(timeMillis / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
  };

  // Handle video press - toggle play/pause on single click
  const handleVideoPress = () => {
    // Toggle play/pause state
    const newPlayingState = !isPlaying;
    setIsPlaying(newPlayingState);
    
    // Show controls briefly
    showVideoControls();
    
    // Play or pause the current video
    const currentVideoRef = videoRefs.current[currentIndex];
    if (currentVideoRef) {
      if (newPlayingState) {
        currentVideoRef.playAsync();
      } else {
        // Show pause icon with animation
        setShowPauseIcon(true);
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 200,
          useNativeDriver: true
        }).start();
        
        // Hide pause icon after a short delay
        if (pauseIconTimeout.current) {
          clearTimeout(pauseIconTimeout.current);
        }
        pauseIconTimeout.current = setTimeout(() => {
          Animated.timing(fadeAnim, {
            toValue: 0,
            duration: 200,
            useNativeDriver: true
          }).start(() => setShowPauseIcon(false));
        }, 800);
        
        currentVideoRef.pauseAsync();
      }
    }
  };
  
  // Add touch handlers for press-to-pause functionality
  const handleTouchStart = () => {
    // Clear any existing touch timer
    if (touchTimer.current) {
      clearTimeout(touchTimer.current);
    }
    
    // Set a timer to detect long press (300ms)
    touchTimer.current = setTimeout(() => {
      if (isPlaying) {
        isTouchHolding.current = true;
        setIsPlaying(false);
        const currentVideoRef = videoRefs.current[currentIndex];
        if (currentVideoRef) {
          currentVideoRef.pauseAsync();
        }
      }
    }, 300);
  };

  const handleTouchEnd = () => {
    // Clear the touch timer
    if (touchTimer.current) {
      clearTimeout(touchTimer.current);
      touchTimer.current = null;
    }
    
    // If we were holding and paused the video, resume playback
    if (isTouchHolding.current) {
      isTouchHolding.current = false;
      setIsPlaying(true);
      const currentVideoRef = videoRefs.current[currentIndex];
      if (currentVideoRef) {
        currentVideoRef.playAsync();
      }
    }
  };

  // Show controls when video is tapped
  const showVideoControls = () => {
    setShowControls(true);
    
    // Clear existing timeout
    if (controlsTimeout.current) {
      clearTimeout(controlsTimeout.current);
    }
    
    // Hide controls after 3 seconds
    controlsTimeout.current = setTimeout(() => {
      setShowControls(false);
    }, 3000);
  };

  // Handle seeking
  const handleSeek = (value) => {
    const currentVideoRef = videoRefs.current[currentIndex];
    if (currentVideoRef && duration > 0) {
      const newPosition = value * duration;
      currentVideoRef.setPositionAsync(newPosition);
      setCurrentTime(newPosition);
      setProgress(value);
    }
  };

  // Handle playback status update
  const onPlaybackStatusUpdate = (status) => {
    if (status.isLoaded) {
      setProgress(status.positionMillis / status.durationMillis);
      setCurrentTime(status.positionMillis);
      setDuration(status.durationMillis);
      
      // When video finishes, replay the same video instead of moving to next
      if (status.didJustFinish) {
        // Replay the current video
        const currentVideoRef = videoRefs.current[currentIndex];
        if (currentVideoRef) {
          currentVideoRef.replayAsync();
        }
      }
    }
  };

  // Handle viewable items changed
  const onViewableItemsChanged = useRef(({ viewableItems }) => {
    if (viewableItems.length > 0) {
      const newIndex = viewableItems[0].index;
      
      // Pause previous video
      if (videoRefs.current[currentIndex] && currentIndex !== newIndex) {
        videoRefs.current[currentIndex].pauseAsync();
      }
      
      // Play new video - always auto-play when a new video becomes visible
      if (videoRefs.current[newIndex]) {
        videoRefs.current[newIndex].playAsync();
        setIsPlaying(true);
      }
      
      setCurrentIndex(newIndex);
    }
  }).current;

  // Handle scroll to index failed
  const onScrollToIndexFailed = (info) => {
    const wait = new Promise(resolve => setTimeout(resolve, 500));
    wait.then(() => {
      flatListRef.current?.scrollToIndex({
        index: info.index,
        animated: false,
      });
    });
  };

  // Handle like functionality
  const handleLike = async (postId) => {
    try {
      const currentPost = posts.find(post => post.id === postId);
      if (!currentPost) return;
      
      // Optimistically update UI
      const updatedPosts = posts.map(post => {
        if (post.id === postId) {
          return {
            ...post,
            is_liked: !post.is_liked,
            likes: post.likes ? [
              { count: post.is_liked ? Math.max(0, post.likes[0]?.count - 1) : (post.likes[0]?.count || 0) + 1 }
            ] : [{ count: 1 }]
          };
        }
        return post;
      });
      setPosts(updatedPosts);
      
      // Call API to update like status
      const { isLiked, likesCount } = await PostsService.toggleLike(postId);
      
      // Update state with actual response from server
      const finalPosts = posts.map(post => {
        if (post.id === postId) {
          return {
            ...post,
            is_liked: isLiked,
            likes: [{ count: likesCount }]
          };
        }
        return post;
      });
      setPosts(finalPosts);
    } catch (error) {
      console.error('Error toggling like:', error);
      Alert.alert('Error', 'Failed to update like');
    }
  };

  // Handle comment functionality
  const handleComment = (postId) => {
    // Pause video before navigating
    if (videoRefs.current[currentIndex]) {
      videoRefs.current[currentIndex].pauseAsync();
      setIsPlaying(false);
    }
    
    navigation.navigate('ShortsComment', { postId });
  };

  // Handle share functionality
  const handleShare = async (post) => {
    try {
      const result = await Share.share({
        message: `Check out this video from ${post.profiles?.username || 'a user'}!\n\n${post.caption || ''}\n\nOpen the app to watch.`,
        url: post.media_url, // This may not work on all platforms
        title: 'Share this video'
      });
      
      if (result.action === Share.sharedAction) {
        if (result.activityType) {
          // shared with activity type of result.activityType
          console.log('Shared with activity type:', result.activityType);
        } else {
          // shared
          console.log('Shared successfully');
        }
      } else if (result.action === Share.dismissedAction) {
        // dismissed
        console.log('Share dismissed');
      }
    } catch (error) {
      Alert.alert('Error', 'Could not share this video');
      console.error('Error sharing:', error);
    }
  };

  // Render each short video item
  const renderItem = ({ item, index }) => {
    // Only render video posts
    if (item.type !== 'video') return null;
    
    // Get like count
    const likeCount = item.likes?.[0]?.count || 0;
    const commentCount = item.comments?.[0]?.count || 0;
    
    return (
      <View style={styles.videoContainer}>
        <TouchableOpacity 
          activeOpacity={1} 
          style={styles.videoWrapper} 
          onPress={handleVideoPress}
          onPressIn={handleTouchStart}
          onPressOut={handleTouchEnd}
        >
          <Video
            ref={ref => { videoRefs.current[index] = ref }}
            source={{ uri: item.media_url }}
            style={styles.video}
            resizeMode="contain"
            play={isPlaying && index === currentIndex && !isTouchHolding.current}
            shouldPlay={isPlaying && index === currentIndex && !isTouchHolding.current}
            isLooping={true}
            loop={true}
            onPlaybackStatusUpdate={onPlaybackStatusUpdate}
            useNativeControls={false}
            rate={1.0}
          />
          
          {/* User info overlay */}
          <LinearGradient 
            colors={['transparent', 'rgba(0,0,0,0.7)']} 
            style={[styles.userInfoOverlay, { paddingBottom: insets.bottom + 20 }]}
          >
            <View style={styles.userInfo}>
              <Text style={styles.username}>{item.profiles?.username || 'User'}</Text>
              <Text style={styles.caption}>{item.caption}</Text>
            </View>
            
            {/* Social interaction buttons */}
            <View style={styles.socialButtons}>
              <TouchableOpacity 
                style={styles.socialButton} 
                onPress={() => handleLike(item.id)}
              >
                <LinearGradient 
                  colors={item.is_liked ? ['#ff00ff', '#9900ff'] : ['rgba(0,0,0,0.5)', 'rgba(0,0,0,0.5)']}
                  style={styles.socialButtonGradient}
                >
                  <Ionicons name={item.is_liked ? 'heart' : 'heart-outline'} size={26} color="#fff" />
                </LinearGradient>
                <Text style={styles.socialButtonText}>{likeCount}</Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                style={styles.socialButton}
                onPress={() => handleComment(item.id)}
              >
                <LinearGradient 
                  colors={['rgba(0,0,0,0.5)', 'rgba(0,0,0,0.5)']}
                  style={styles.socialButtonGradient}
                >
                  <Ionicons name="chatbubble-outline" size={24} color="#fff" />
                </LinearGradient>
                <Text style={styles.socialButtonText}>{commentCount}</Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                style={styles.socialButton}
                onPress={() => handleShare(item)}
              >
                <LinearGradient 
                  colors={['rgba(0,0,0,0.5)', 'rgba(0,0,0,0.5)']}
                  style={styles.socialButtonGradient}
                >
                  <Ionicons name="share-social-outline" size={24} color="#fff" />
                </LinearGradient>
              </TouchableOpacity>
            </View>
          </LinearGradient>

          {/* Video controls */}
          {showControls && (
            <LinearGradient 
              colors={['rgba(0,0,0,0.7)', 'transparent', 'rgba(0,0,0,0.7)']} 
              style={styles.controlsOverlay}
            >
              {/* Top controls */}
              <View style={[styles.topControls, { paddingTop: insets.top }]}>
                <TouchableOpacity 
                  style={styles.backButton} 
                  onPress={() => navigation.goBack()}
                >
                  <Ionicons name="arrow-back" size={28} color="#fff" />
                </TouchableOpacity>
              </View>
              
              {/* Bottom controls */}
              <View style={styles.bottomControls}>
                <View style={styles.timeContainer}>
                  <Text style={styles.timeText}>{formatTime(currentTime)}</Text>
                  <Text style={styles.timeText}>{formatTime(duration)}</Text>
                </View>
                
                <View style={styles.seekbarContainer}>
                  <View style={styles.progressBackground} />
                  <View style={[styles.progressBar, { width: `${progress * 100}%` }]} />
                  <View style={styles.seekbarTouchable}>
                    <TouchableOpacity 
                      style={[styles.seekKnob, { left: `${progress * 100}%` }]}
                    />
                    <View 
                      style={styles.seekbarTouchArea}
                      onTouchStart={(event) => {
                        const { locationX } = event.nativeEvent;
                        const seekPosition = locationX / width;
                        handleSeek(Math.max(0, Math.min(1, seekPosition)));
                      }}
                    />
                  </View>
                </View>
              </View>
            </LinearGradient>
          )}
          
          {/* Pause icon that appears briefly when video is paused */}
          {showPauseIcon && index === currentIndex && (
            <Animated.View style={[styles.pauseIconContainer, { opacity: fadeAnim }]}>
              <Ionicons name="pause" size={50} color="#fff" />
            </Animated.View>
          )}
        </TouchableOpacity>
      </View>
    );
  };

  if (loading) {
    return (
      <View style={[styles.container, styles.centered]}>
        <ActivityIndicator size="large" color="#ff00ff" />
      </View>
    );
  }

  if (posts.length === 0) {
    return (
      <View style={[styles.container, styles.centered]}>
        <Text style={styles.emptyText}>No shorts available</Text>
        <TouchableOpacity 
          style={styles.backButton} 
          onPress={() => navigation.goBack()}
        >
          <Text style={styles.backButtonText}>Go Back</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <FlatList
        ref={flatListRef}
        data={posts.filter(post => post.type === 'video')}
        keyExtractor={(item) => item.id.toString()}
        renderItem={renderItem}
        pagingEnabled
        showsVerticalScrollIndicator={false}
        windowSize={3}
        maxToRenderPerBatch={3}
        initialNumToRender={3}
        onViewableItemsChanged={onViewableItemsChanged}
        viewabilityConfig={{
          itemVisiblePercentThreshold: 50
        }}
        onScrollToIndexFailed={onScrollToIndexFailed}
        vertical
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#000',
  },
  centered: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  emptyText: {
    color: '#fff',
    fontSize: 18,
    marginBottom: 20,
  },
  backButtonText: {
    color: '#ff00ff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  videoContainer: {
    width,
    height,
    backgroundColor: '#000',
  },
  videoWrapper: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  video: {
    width,
    height,
  },
  userInfoOverlay: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    padding: 20,
  },
  userInfo: {
    marginBottom: 20,
  },
  socialButtons: {
    position: 'absolute',
    right: 10,
    bottom: 80,
    alignItems: 'center',
  },
  socialButton: {
    alignItems: 'center',
    marginBottom: 15,
  },
  socialButtonGradient: {
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 5,
  },
  socialButtonText: {
    color: '#fff',
    fontSize: 12,
  },
  username: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 5,
  },
  caption: {
    color: '#fff',
    fontSize: 14,
  },
  controlsOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'space-between',
  },
  topControls: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    padding: 20,
  },
  backButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  playPauseButton: {
    alignSelf: 'center',
  },
  playButtonGradient: {
    width: 70,
    height: 70,
    borderRadius: 35,
    justifyContent: 'center',
    alignItems: 'center',
  },
  bottomControls: {
    padding: 20,
  },
  timeContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 10,
  },
  timeText: {
    color: '#fff',
    fontSize: 12,
  },
  seekbarContainer: {
    height: 20,
    justifyContent: 'center',
    position: 'relative',
  },
  progressBackground: {
    position: 'absolute',
    left: 0,
    right: 0,
    height: 3,
    backgroundColor: 'rgba(255,255,255,0.3)',
    borderRadius: 1.5,
  },
  progressBar: {
    position: 'absolute',
    left: 0,
    height: 3,
    backgroundColor: '#ff00ff',
    borderRadius: 1.5,
  },
  seekbarTouchable: {
    position: 'absolute',
    left: 0,
    right: 0,
    height: 20,
  },
  seekKnob: {
    position: 'absolute',
    width: 15,
    height: 15,
    borderRadius: 7.5,
    backgroundColor: '#ff00ff',
    transform: [{ translateX: -7.5 }],
    top: -6,
  },
  seekbarTouchArea: {
    position: 'absolute',
    left: 0,
    right: 0,
    height: 20,
  },
  playIconOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.3)',
  },
  pauseIconContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.3)',
    opacity: 0.7,
  },
});

export default ShortsScreen;